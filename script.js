// === Chat (invariato) === const API_BASE = "https://erik-cv-backend.onrender.com"; document.getElementById("year").textContent = new Date().getFullYear(); const chatlog = document.getElementById("chatlog"); const form = document.getElementById("chatform"); const input = document.getElementById("question"); function addMsg(text, who) { const div = document.createElement("div"); div.className = msg ${who}; div.textContent = text; chatlog.appendChild(div); chatlog.scrollTop = chatlog.scrollHeight; return div; } form.addEventListener("submit", async (e) => { e.preventDefault(); const q = input.value.trim(); if (!q) return; addMsg(q, "me"); input.value = ""; const pending = addMsg("⏳ Thinking…", "bot"); try { const r = await fetch(${API_BASE}/api/chat, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ question: q }), }); const data = await r.json(); pending.textContent = data.answer || "No answer."; } catch { pending.textContent = "Network error."; } }); // === Reveal on scroll (una-tantum, nessuna forzatura) === (() => { // Se l’utente preferisce meno animazioni, rendi tutto visibile subito if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) { document.querySelectorAll(".fade").forEach(el => el.classList.add("visible")); document.querySelectorAll(".card").forEach(el => el.classList.add("active")); return; } const targets = document.querySelectorAll(".fade, .card"); if (!targets.length) return; const io = new IntersectionObserver((entries, obs) => { entries.forEach(entry => { if (!entry.isIntersecting) return; const el = entry.target; if (el.classList.contains("fade")) el.classList.add("visible"); if (el.classList.contains("card")) el.classList.add("active"); // Una volta visibile, smetti di osservarlo: niente toggle, niente jank obs.unobserve(el); }); }, { threshold: 0.2, // circa 20% visibile rootMargin: "0px" // nessuna spinta anticipata }); targets.forEach(el => io.observe(el)); })();
